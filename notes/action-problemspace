
# action-space-execute

OP advance-current-subgoal
	When desired.satisfied = true 
		and there is another subgoal on the action-id
	Apply: change action-operator.current-subgoal

OP complete-action
	If desired.satisfied = true -> status success
	If current-action.unrecoverable-failure <name> -> status failure
	Apply: add status to current-action and remove output commands

OP copy-action
	If there is an action-operator but no current-action
	Apply: push a new-action-segment onto the action-stack
		with the copied action 

OP learn-task-subaction
	If there is a child action that came from instruction
	Apply: Learn a new proposal rule for the subaction (^created-subaction <h>)

OP child-action
	If there is a child-action with an execution-operator, propose it

OP smem-query
	If there is no action-id for the action-operator, then retrieve it

OP create-initial-subgoal
	If the action has a goal with a subgoal, add current-subgoal to action-operator

OP wait
	If propose-wait = true is on state, propose a wait operator


If the child action has a status, pop that action
	

# elaborations
action-stack (copied down from top-state)
action-operator (copied from superstate.operator)
current-action (segment containing the action-operator)
parent-action (previous action stack segment)
child-action (next action stack segment)



# action-operator
	name
	handle
	current-subgoal <h>


# action-segment
	execution-operator <action-op> 
	unlearned-subaction <handle> (Removed once operator successfully applied)
	action-source instruction (Added if child came from instruction)
	assigned-subaction-handle true (Added if learn-task-subaction is finished)
	performed <sub-handle> (Added when child action with perform-once succeeds)
	performed-subaction <sub-handle> (Added when any child action succeeds)






# smem 
(<action-id>
	^procedural
		^subactions
			^subaction
				^handle <h>
				^learned-proposal true
				





  
