
# A primitive action has been selected to be executed
# Create a new action segment to push onto the top-state action-stack
sp {action*problem-space*execute*apply*action-operator*create*new-action-segment
   (state <s> -^name execute-action
               ^problem-space.name action
              ^problem-space.action.type execute
             -^child-action <child>
              ^operator <o>)
   (<o> ^name <name>
        ^action-handle <action-handle>)
-->
   (<s> ^new-action-segment <seg>)
   (<seg> ^action-handle <action-handle>
         ^start-of-execution true
         ^execution-operator <ex-op>)
   (<ex-op> ^name <name>
            ^action-handle <action-handle>)
}


######################################################################
# 
# Level 1 Copy: surface arguments
#
######################################################################

sp {action*problem-space*execute*apply*action-operator*copy*info*execution-operator
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment.execution-operator <ex>)
   (<o> ^{ <att> << subaction-handle perform >> } <val>)
-->
   (<ex> ^<att> <val>)
}

sp {action*problem-space*execute*apply*action-operator*mark*copied-level1
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>)
   (<o> ^action-handle <action-handle>)
   (<seg> ^action-handle <action-handle>)
-->
   (<s> ^copied-level1 true)
}

# Copy an object argument
sp {action*problem-space*execute*apply*action-operator*copy*object*arg
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>
              ^world.objects.object <obj>)
  (<o> ^action-handle <action-handle>
        ^<arg-name> <arg>)
   (<arg> ^arg-type object
          ^id <obj>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator <ex-op>)
-->
   (<ex-op> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type object
              ^id <obj>)
}

# Copy an abstract object argument
sp {action*problem-space*execute*apply*action-operator*copy*abstract*object*arg
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>
              -^world.objects.object <obj>)
  (<o> ^action-handle <action-handle>
        ^<arg-name> <arg>)
   (<arg> ^arg-type object
          ^id <obj>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator <ex-op>)
-->
   (<ex-op> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type object
              ^id <new-obj>)
   (<new-obj> ^item-type object
              ^predicates <new-preds>)
}

# Copy concept argument
sp {action*problem-space*execute*apply*action-operator*copy*concept*arg
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>)
  (<o> ^action-handle <action-handle>
        ^<arg-name> <arg>)
   (<arg> ^arg-type concept
          ^handle <concept>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator <ex-op>)
-->
   (<ex-op> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type concept
               ^handle <concept>)
}

# Copy a predicate arg
sp {action*problem-space*execute*apply*action-operator*copy*predicate*arg
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>
              ^world.objects.object <pred-obj>)
  (<o> ^action-handle <action-handle>
        ^<arg-name> <arg>)
   (<arg> ^arg-type predicate
           ^handle <pred-handle>
           ^2 <pred-obj>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator <ex-op>)
-->
   (<ex-op> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type predicate
              ^handle <pred-handle>
              ^2 <pred-obj>)
}

# copy a predicate arg with a default-handle
sp {action*problem-space*execute*apply*action-operator*copy*predicate*arg*default-handle
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>
              ^world.objects.object <pred-obj>)
  (<o> ^action-handle <action-handle>
        ^<arg-name> <arg>)
   (<arg> ^arg-type predicate
         -^handle
           ^default-handle <pred-handle>
           ^2 <pred-obj>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator <ex-op>)
-->
   (<ex-op> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type predicate
              ^handle <pred-handle>
              ^2 <pred-obj>)
}

# Copy a predicate arg with a waypoint
sp {action*problem-space*execute*apply*action-operator*copy*predicate*arg*waypoint
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>
              ^top-state.maps.map.waypoint <wp>)
  (<o> ^action-handle <action-handle>
        ^<arg-name> <arg>)
   (<arg> ^arg-type predicate
           ^handle <pred-handle>
           ^2 <wp>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator <ex-op>)
-->
   (<ex-op> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type predicate
              ^handle <pred-handle>
              ^2 <wp>)
}

# Copy a predicate arg with an abstract object
sp {action*problem-space*execute*apply*action-operator*copy*abstract*predicate*arg
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>
              -^world.objects.object <pred-obj>
              -^top-state.maps.map.waypoint <pred-obj>)
  (<o> ^action-handle <action-handle>
        ^<arg-name> <arg>)
   (<arg> ^arg-type predicate
          ^handle <pred-handle>
           ^2 <pred-obj>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator <ex-op>)
-->
   (<ex-op> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type predicate
              ^handle <pred-handle>
              ^2 <new-obj>)
   (<new-obj> ^item-type object
              ^predicates <preds>) 
}


# copy a predicate arg with a default-handle and abstract object
sp {action*problem-space*execute*apply*action-operator*copy*abstract*predicate*arg*default-handle
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>
              -^world.objects.object <pred-obj>
              -^top-state.maps.map.waypoint <pred-obj>)
   (<o> ^action-handle <action-handle>
        ^<arg-name> <arg>)
   (<arg> ^arg-type predicate
         -^handle
           ^default-handle <pred-handle>
           ^2 <pred-obj>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator <ex-op>)
-->
   (<ex-op> ^<arg-name> <new-arg>)
   (<new-arg> ^arg-type predicate
              ^handle <pred-handle>
              ^2 <new-obj>)
   (<new-obj> ^item-type object
              ^predicates <preds>) 
}

# copy the until clause (level 1)
sp {action*problem-space*execute*apply*action-operator*copy*until-clause
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>)
   (<o> ^action-handle <action-handle>
        ^until-clause <until>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator <ex-op>)
-->
   (<ex-op> ^until-clause <new-clause>)
}

######################################################################
# 
# Level 2 Copy: deeper arguments
#
######################################################################

sp {action*problem-space*execute*apply*action-operator*mark*copied-level2
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>
              ^copied-level1 true)
   (<o> ^action-handle <action-handle>)
   (<seg> ^action-handle <action-handle>)
-->
   (<s> ^copied-level2 true)
}

# copy predicates onto an abstract object argument
sp {action*problem-space*execute*apply*action-operator*copy*abstract*object*predicates
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>
             -^world.objects.object <obj>)
   (<o> ^action-handle <action-handle>
        ^<arg-name> <arg>)
   (<arg> ^arg-type object
          ^id <obj>
          ^id.predicates.<prop-name> <pred-name>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator.<arg-name>.id.predicates <new-preds>)
-->
   (<new-preds> ^<prop-name> <pred-name>)
}

# copy predicates onto an abstract predicate argument object
sp {action*problem-space*execute*apply*action-operator*copy*abstract*predicate*object*predicates
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>
             -^world.objects.object <pred-obj>)
   (<o> ^action-handle <action-handle>
        ^<arg-name> <arg>)
   (<arg> ^arg-type predicate
          ^2 <pred-obj>
          ^{2}.predicates.<prop-name> <pred-name>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator.<arg-name>.{2}.predicates <new-preds>)
-->
   (<new-preds> ^<prop-name> <pred-name>)
}

# copy a state predicate on an until-clause
sp {action*problem-space*execute*apply*action-operator*copy*until-clause*state*predicate
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>)
   (<o> ^action-handle <action-handle>
        ^until-clause.predicate <until-pred>)
   (<until-pred> ^type state
                 ^handle <pred-handle>
                 ^1 <obj>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator.until-clause <new-until>)
-->
   (<new-until> ^predicate <new-pred>)
   (<new-pred> ^type state
               ^handle <pred-handle>
               ^1 <obj>)
}

# copy a relation predicate from an until clause
sp {action*problem-space*execute*apply*action-operator*copy*until-clause*relation*predicate
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^operator <o>
              ^new-action-segment <seg>)
   (<o> ^action-handle <action-handle>
        ^until-clause.predicate <until-pred>)
   (<until-pred> ^type relation
                 ^handle <pred-handle>
                 ^1 <obj1>
                 ^2 <obj2>)
   (<seg> ^action-handle <action-handle>
          ^execution-operator.until-clause <new-until>)
-->
   (<new-until> ^predicate <new-pred>)
   (<new-pred> ^type relation
               ^handle <pred-handle>
               ^1 <obj1>
               ^2 <obj2>)
}

######################################################################
# 
# Push action onto stack
#
######################################################################

sp {action*problem-space*execute*apply*action-operator*push*action
   (state <s> ^problem-space.name action
              ^problem-space.action.type execute
              ^copied-level2 true
              ^operator <o>
              ^new-action-segment <seg>
              ^top-state.action-stack.changes <c>)
   (<o> ^action-handle <action-handle>)
   (<seg> ^action-handle <action-handle>)
-->
   (<c> ^push <seg>)
}
