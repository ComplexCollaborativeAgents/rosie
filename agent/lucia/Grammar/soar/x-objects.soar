#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\x-objects.ecg'.

#   Hall schema
sp {comprehend-word*evoked-schema*Hall*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Hall
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Hall
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Hall)
   (<e1> ^schema SpatialShape
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value spatial-shape)
   (<c2> ^attr spatial-shape
         ^value hall1)
}

#   Hall schema
sp {comprehend-word*evoked-schema*Hall*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Hall
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Hall)
   (<e1> ^schema SpatialShape
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr rosie-category
         ^value spatial-shape)
   (<c2> ^attr spatial-shape
         ^value hall1)
}

#   End schema
sp {comprehend-word*evoked-schema*End*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema End
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name End
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a End)
   (<e1> ^schema SpatialShape
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value spatial-shape)
   (<c2> ^attr spatial-shape
         ^value end1)
}

#   End schema
sp {comprehend-word*evoked-schema*End*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema End
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a End)
   (<e1> ^schema SpatialShape
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr rosie-category
         ^value spatial-shape)
   (<c2> ^attr spatial-shape
         ^value end1)
}

#   Stapler schema
sp {comprehend-word*evoked-schema*Stapler*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Stapler
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Stapler
               ^is <a>
               ^name |stapler|
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Stapler)
   (<e1> ^schema RosieObject
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value object)
   (<c2> ^attr movable
         ^value true)
}

#   Stapler schema
sp {comprehend-word*evoked-schema*Stapler*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Stapler
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^name |stapler|
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Stapler)
   (<e1> ^schema RosieObject
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value object)
   (<c2> ^attr movable
         ^value true)
}

#   Soda schema
sp {comprehend-word*evoked-schema*Soda*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Soda
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Soda
               ^is <a>
               ^constraint <c1>)
   (<a> ^a Soda)
   (<e1> ^schema Block
         ^target <e-target>)
   (<c1> ^attr shape
         ^value soda1)
}

#   Soda schema
sp {comprehend-word*evoked-schema*Soda*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Soda
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Soda)
   (<e1> ^schema Block
         ^target <e-target>)
   (<e-target> ^constraint <c1>)
   (<c1> ^attr shape
         ^value soda1)
}

#   Concept schema
sp {comprehend-word*evoked-schema*Concept*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Concept
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Concept
               ^is <a>
               ^concept-type nil
               ^concept-handle nil)
   (<a> ^a Concept)
   (<e1> ^schema Entity
         ^target <e-target>)
}

#   Concept schema
sp {comprehend-word*evoked-schema*Concept*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Concept
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^concept-type nil
               ^concept-handle nil)
   (<a> ^a Concept)
   (<e1> ^schema Entity
         ^target <e-target>)
}

#   Task schema
sp {comprehend-word*evoked-schema*Task*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Task
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Task
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Task)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value concept)
   (<c2> ^attr concept-handle
         ^value task1)
}

#   Task schema
sp {comprehend-word*evoked-schema*Task*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Task
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Task)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr rosie-category
         ^value concept)
   (<c2> ^attr concept-handle
         ^value task1)
}

#   Units schema
sp {comprehend-word*evoked-schema*Units*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Units
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Units
               ^is <a>
               ^type nil
               ^constraint <c1>)
   (<a> ^a Units)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value concept)
}

#   Units schema
sp {comprehend-word*evoked-schema*Units*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Units
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^type nil
               ^constraint <c1>)
   (<a> ^a Units)
   (<e1> ^schema Concept
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value concept)
}

