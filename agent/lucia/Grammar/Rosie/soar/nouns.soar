#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\nouns.ecg'.

#   SHAPE construction
sp {comprehend-word*apply*lexical-access*SHAPE-shape
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |shape|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name SHAPE
          ^is <a>
          ^orth |shape|
          ^f <form>
          ^m <meaning>
          ^subcase-of PropertyClassName
          ^evokes <e1>)
   (<a> ^a SHAPE)
   (<e1> ^schema PropertyClass
         ^target <meaning>)
}

#   SHAPE self.m.name <-- "shape" constraint
sp {comprehend-word*SHAPE-constraint*self-m-name*ASSIGN*shape
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SHAPE
          ^orth |shape|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |shape| })
-->
   (<l-slot1> ^name <target> -
              ^name |shape|)
}

#   COLOR construction
sp {comprehend-word*apply*lexical-access*COLOR-color
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |color|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name COLOR
          ^is <a>
          ^orth |color|
          ^f <form>
          ^m <meaning>
          ^subcase-of PropertyClassName
          ^evokes <e1>)
   (<a> ^a COLOR)
   (<e1> ^schema PropertyClass
         ^target <meaning>)
}

#   COLOR self.m.name <-- "color" constraint
sp {comprehend-word*COLOR-constraint*self-m-name*ASSIGN*color
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a COLOR
          ^orth |color|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |color| })
-->
   (<l-slot1> ^name <target> -
              ^name |color|)
}

#   SIZE construction
sp {comprehend-word*apply*lexical-access*SIZE-size
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |size|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name SIZE
          ^is <a>
          ^orth |size|
          ^f <form>
          ^m <meaning>
          ^subcase-of PropertyClassName
          ^evokes <e1>)
   (<a> ^a SIZE)
   (<e1> ^schema PropertyClass
         ^target <meaning>)
}

#   SIZE self.m.name <-- "size" constraint
sp {comprehend-word*SIZE-constraint*self-m-name*ASSIGN*size
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SIZE
          ^orth |size|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |size| })
-->
   (<l-slot1> ^name <target> -
              ^name |size|)
}

#   LOCATION-class construction
sp {comprehend-word*apply*lexical-access*LOCATION-class-location
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |location|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name LOCATION-class
          ^is <a>
          ^orth |location|
          ^f <form>
          ^m <meaning>
          ^subcase-of PropertyClassName
          ^evokes <e1>)
   (<a> ^a LOCATION-class)
   (<e1> ^schema PropertyClass
         ^target <meaning>)
}

#   LOCATION-class self.m.name <-- "location" constraint
sp {comprehend-word*LOCATION-class-constraint*self-m-name*ASSIGN*location
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a LOCATION-class
          ^orth |location|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |location| })
-->
   (<l-slot1> ^name <target> -
              ^name |location|)
}

#   LOCATION-noun construction
sp {comprehend-word*apply*lexical-access*LOCATION-noun-location
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |location|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name LOCATION-noun
          ^is <a>
          ^orth |location|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a LOCATION-noun)
   (<e1> ^schema Location
         ^target <meaning>)
}

#   KITCHEN construction
sp {comprehend-word*apply*lexical-access*KITCHEN-kitchen
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |kitchen|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name KITCHEN
          ^is <a>
          ^orth |kitchen|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a KITCHEN)
   (<e1> ^schema Kitchen
         ^target <meaning>)
}

#   TABLE construction
sp {comprehend-word*apply*lexical-access*TABLE-table
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |table|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name TABLE
          ^is <a>
          ^orth |table|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a TABLE)
   (<e1> ^schema Table
         ^target <meaning>)
}

#   STOVE construction
sp {comprehend-word*apply*lexical-access*STOVE-stove
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |stove|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name STOVE
          ^is <a>
          ^orth |stove|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a STOVE)
   (<e1> ^schema Stove
         ^target <meaning>)
}

#   PANTRY construction
sp {comprehend-word*apply*lexical-access*PANTRY-pantry
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |pantry|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name PANTRY
          ^is <a>
          ^orth |pantry|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a PANTRY)
   (<e1> ^schema Pantry
         ^target <meaning>)
}

#   GARBAGE construction
sp {comprehend-word*apply*lexical-access*GARBAGE-garbage
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |garbage|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name GARBAGE
          ^is <a>
          ^orth |garbage|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a GARBAGE)
   (<e1> ^schema Garbage
         ^target <meaning>)
}

#   BLOCK construction
sp {comprehend-word*apply*lexical-access*BLOCK-block
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |block|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name BLOCK
          ^is <a>
          ^orth |block|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a BLOCK)
   (<e1> ^schema Block
         ^target <meaning>)
}

#   SPHERE-class construction
sp {comprehend-word*apply*lexical-access*SPHERE-class-sphere
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |sphere|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name SPHERE-class
          ^is <a>
          ^orth |sphere|
          ^f <form>
          ^m <meaning>
          ^subcase-of PropertyClassName
          ^evokes <e1>)
   (<a> ^a SPHERE-class)
   (<e1> ^schema PropertyClass
         ^target <meaning>)
}

#   SPHERE-class self.m.name <-- "sphere1" constraint
sp {comprehend-word*SPHERE-class-constraint*self-m-name*ASSIGN*sphere1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SPHERE-class
          ^orth |sphere|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |sphere1| })
-->
   (<l-slot1> ^name <target> -
              ^name |sphere1|)
}

#   SPHERE-noun construction
sp {comprehend-word*apply*lexical-access*SPHERE-noun-sphere
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |sphere|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name SPHERE-noun
          ^is <a>
          ^orth |sphere|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a SPHERE-noun)
   (<e1> ^schema Sphere
         ^target <meaning>)
}

#   TRIANGLE-class construction
sp {comprehend-word*apply*lexical-access*TRIANGLE-class-triangle
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |triangle|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name TRIANGLE-class
          ^is <a>
          ^orth |triangle|
          ^f <form>
          ^m <meaning>
          ^subcase-of PropertyClassName
          ^evokes <e1>)
   (<a> ^a TRIANGLE-class)
   (<e1> ^schema PropertyClass
         ^target <meaning>)
}

#   TRIANGLE-class self.m.name <-- "triangle1" constraint
sp {comprehend-word*TRIANGLE-class-constraint*self-m-name*ASSIGN*triangle1
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TRIANGLE-class
          ^orth |triangle|
          ^m <l-slot1>)
   (<l-slot1> ^name { <target> <> |triangle1| })
-->
   (<l-slot1> ^name <target> -
              ^name |triangle1|)
}

#   TRIANGLE-noun construction
sp {comprehend-word*apply*lexical-access*TRIANGLE-noun-triangle
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |triangle|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name TRIANGLE-noun
          ^is <a>
          ^orth |triangle|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a TRIANGLE-noun)
   (<e1> ^schema Triangle
         ^target <meaning>)
}

#   TRIANGLE-noun self.features.number <-- "sg" constraint
sp {comprehend-word*TRIANGLE-noun-constraint*self-features-number*ASSIGN*sg
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TRIANGLE-noun
          ^orth |triangle|
          ^features <l-slot1>)
   (<l-slot1> ^number { <target> <> |sg| })
-->
   (<l-slot1> ^number <target> -
              ^number |sg|)
}

#   TRIANGLES construction
sp {comprehend-word*apply*lexical-access*TRIANGLES-triangles
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |triangles|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name TRIANGLES
          ^is <a>
          ^orth |triangles|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a TRIANGLES)
   (<e1> ^schema Triangle
         ^target <meaning>)
}

#   TRIANGLES self.features.number <-- "pl" constraint
sp {comprehend-word*TRIANGLES-constraint*self-features-number*ASSIGN*pl
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TRIANGLES
          ^orth |triangles|
          ^features <l-slot1>)
   (<l-slot1> ^number { <target> <> |pl| })
-->
   (<l-slot1> ^number <target> -
              ^number |pl|)
}

#   RECTANGLE construction
sp {comprehend-word*apply*lexical-access*RECTANGLE-rectangle
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |rectangle|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name RECTANGLE
          ^is <a>
          ^orth |rectangle|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a RECTANGLE)
   (<e1> ^schema Rectangle
         ^target <meaning>)
}

#   RECTANGLE self.features.number <-- "sg" constraint
sp {comprehend-word*RECTANGLE-constraint*self-features-number*ASSIGN*sg
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RECTANGLE
          ^orth |rectangle|
          ^features <l-slot1>)
   (<l-slot1> ^number { <target> <> |sg| })
-->
   (<l-slot1> ^number <target> -
              ^number |sg|)
}

#   BOX construction
sp {comprehend-word*apply*lexical-access*BOX-box
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |box|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name BOX
          ^is <a>
          ^orth |box|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a BOX)
   (<e1> ^schema Box
         ^target <meaning>)
}

#   OBJECT construction
sp {comprehend-word*apply*lexical-access*OBJECT-object
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |object|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name OBJECT
          ^is <a>
          ^orth |object|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a OBJECT)
   (<e1> ^schema Object
         ^target <meaning>)
}

#   WALL construction
sp {comprehend-word*apply*lexical-access*WALL-wall
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |wall|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name WALL
          ^is <a>
          ^orth |wall|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a WALL)
   (<e1> ^schema Wall
         ^target <meaning>)
}

#   WAYPOINT construction
sp {comprehend-word*apply*lexical-access*WAYPOINT-waypoint
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |waypoint|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name WAYPOINT
          ^is <a>
          ^orth |waypoint|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a WAYPOINT)
   (<e1> ^schema Waypoint
         ^target <meaning>)
}

#   DOORWAY construction
sp {comprehend-word*apply*lexical-access*DOORWAY-doorway
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |doorway|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name DOORWAY
          ^is <a>
          ^orth |doorway|
          ^f <form>
          ^m <meaning>
          ^subcase-of CommonNoun
          ^evokes <e1>)
   (<a> ^a DOORWAY)
   (<e1> ^schema Doorway
         ^target <meaning>)
}

