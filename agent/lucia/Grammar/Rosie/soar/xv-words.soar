#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\xv-words.ecg'.

#   ME construction
sp {comprehend-word*apply*lexical-access*ME-me
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |me|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name ME
          ^is <a>
          ^orth |me|
          ^f <form>
          ^m <meaning>
          ^subcase-of Pronoun)
   (<a> ^a ME)
}

#   ME self.features.case <-- "nom" constraint
sp {comprehend-word*ME-constraint*self-features-case*ASSIGN*nom
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ME
          ^orth |me|
          ^features <l-slot1>)
   (<l-slot1> ^case { <target> <> |nom| })
-->
   (<l-slot1> ^case <target> -
              ^case |nom|)
}

#   ME self.features.person <-- "1st" constraint
sp {comprehend-word*ME-constraint*self-features-person*ASSIGN*1st
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ME
          ^orth |me|
          ^features <l-slot1>)
   (<l-slot1> ^person { <target> <> |1st| })
-->
   (<l-slot1> ^person <target> -
              ^person |1st|)
}

#   ME self.m.category <-- @animate constraint
sp {comprehend-word*ME-constraint*self-m-category*ASSIGN*AT-animate
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ME
          ^orth |me|
          ^m <l-slot1>)
   (<l-slot1> ^category { <target> <> |animate| })
-->
   (<l-slot1> ^category <target> -
              ^category |animate|)
}

#   THESE construction
sp {comprehend-word*apply*lexical-access*THESE-these
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |these|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name THESE
          ^is <a>
          ^orth |these|
          ^f <form>
          ^m <meaning>
          ^subcase-of NPSpecifier)
   (<a> ^a THESE)
}

#   ALL construction
sp {comprehend-word*apply*lexical-access*ALL-all
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |all|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name ALL
          ^is <a>
          ^orth |all|
          ^f <form>
          ^m <meaning>
          ^subcase-of Quantifier)
   (<a> ^a ALL)
}

#   ALL-OF construction
sp {comprehend-word*apply*lexical-access*ALL-OF-all-of
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |of|)
   (<s> ^superstate.comprehension.word-stack <previous1>)
   (<previous1> ^orth |all|
                ^previous <previous2>)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name ALL-OF
          ^is <a>
          ^orth |all of|
          ^f <form>
          ^m <meaning>
          ^subcase-of Quantifier
          ^multi-word <previous1>)
   (<a> ^a ALL-OF)
}

#   SOME construction
sp {comprehend-word*apply*lexical-access*SOME-some
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |some|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name SOME
          ^is <a>
          ^orth |some|
          ^f <form>
          ^m <meaning>
          ^subcase-of Quantifier)
   (<a> ^a SOME)
}

#   AS construction
sp {comprehend-word*apply*lexical-access*AS-as
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^input.word <word>)
   (<o> ^name lexical-access)
   (<word> ^orth |as|)
-->
   (<s> ^cxn <cxn>)
   (<cxn> ^cxn-name AS
          ^is <a>
          ^orth |as|
          ^f <form>
          ^m <meaning>
          ^subcase-of Conjunction)
   (<a> ^a AS)
}

