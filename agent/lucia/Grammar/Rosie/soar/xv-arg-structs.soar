#   Soar code produced automatically 
#   from file '..\Lucia\Grammars\Rosie\ecg\xv-arg-structs.ecg'.

#   Propose an operator for the DiTransitiveCommand construction
sp {comprehend-word*propose*match-construction*DiTransitiveCommand
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <theme>)
   (<theme> ^is.a RefExpr
            ^previous <command>)
   (<command> ^is.a TransitiveCommand
              ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name DiTransitiveCommand
        ^span 2
        ^theme <theme>
        ^command <command>
        ^previous <previous>
        ^debug-info (concat |Match a DiTransitiveCommand construction, combination 0.|))
}

#   Apply the operator for the DiTransitiveCommand construction
sp {comprehend-word*apply*match-construction*DiTransitiveCommand
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name DiTransitiveCommand
        ^command <command>
        ^theme <theme>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name DiTransitiveCommand
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^command <command>
              ^theme <theme>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a DiTransitiveCommand)
   (<constituents> ^command <command>
                   ^theme <theme>)
   (<e1> ^schema DoTransfer
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a DiTransitiveCommand construction.|))
}

#   DiTransitiveCommand self.m.action <--> command.verb.m constraint
sp {comprehend-word*DiTransitiveCommand-constraint*self-m-action*UNIFY*command-verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DiTransitiveCommand
          ^m <l-slot1>
          ^command <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^verb <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   DiTransitiveCommand self.m.object <--> command.object.m constraint
sp {comprehend-word*DiTransitiveCommand-constraint*self-m-object*UNIFY*command-object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DiTransitiveCommand
          ^m <l-slot1>
          ^command <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^object <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   DiTransitiveCommand self.m.object2 <--> theme.m constraint
sp {comprehend-word*DiTransitiveCommand-constraint*self-m-object2*UNIFY*theme-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a DiTransitiveCommand
          ^m <l-slot1>
          ^theme <r-slot1>)
   (<l-slot1> ^object2 { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object2 <target> -
              ^object2 <value>)
}

#   RememberAasB construction
sp {comprehend-word*generalize-cxn*RememberAasB*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of RememberAasB
          ^is <a>)
   (<a> -^a RememberAasB)
-->
   (<a> ^a RememberAasB)
   (<cxn> ^subcase-of RememberAasB -
          ^subcase-of Imperative)
}

#   Propose an operator for the RememberRefExprasB construction
sp {comprehend-word*propose*match-construction*RememberRefExprasB
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <target>)
   (<target> ^is.a RefExpr
             ^previous <connector>)
   (<connector> ^is.a AS
                ^previous <object>)
   (<object> ^is.a RefExpr
             ^previous <verb>)
   (<verb> ^is.a REMEMBER
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RememberRefExprasB
        ^span 4
        ^target <target>
        ^connector <connector>
        ^object <object>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a RememberRefExprasB construction, combination 0.|))
}

#   Apply the operator for the RememberRefExprasB construction
sp {comprehend-word*apply*match-construction*RememberRefExprasB
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RememberRefExprasB
        ^verb <verb>
        ^object <object>
        ^connector <connector>
        ^target <target>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RememberRefExprasB
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of RememberAasB
              ^constituents <constituents>
              ^verb <verb>
              ^object <object>
              ^connector <connector>
              ^target <target>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a RememberRefExprasB)
   (<constituents> ^verb <verb>
                   ^object <object>
                   ^connector <connector>
                   ^target <target>)
   (<e1> ^schema DoTransfer
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RememberRefExprasB construction.|))
}

#   RememberRefExprasB self.m.action <--> verb.m constraint
sp {comprehend-word*RememberRefExprasB-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RememberRefExprasB
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   RememberRefExprasB self.m.object <--> object.m constraint
sp {comprehend-word*RememberRefExprasB-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RememberRefExprasB
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   RememberRefExprasB self.m.object2 <--> target.m constraint
sp {comprehend-word*RememberRefExprasB-constraint*self-m-object2*UNIFY*target-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RememberRefExprasB
          ^m <l-slot1>
          ^target <r-slot1>)
   (<l-slot1> ^object2 { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object2 <target> -
              ^object2 <value>)
}

#   Propose an operator for the RememberConditionasB construction
sp {comprehend-word*propose*match-construction*RememberConditionasB
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <target>)
   (<target> ^is.a RefExpr
             ^previous <connector>)
   (<connector> ^is.a AS
                ^previous <condition>)
   (<condition> ^is.a IfCondition
                ^previous <verb>)
   (<verb> ^is.a REMEMBER
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RememberConditionasB
        ^span 4
        ^target <target>
        ^connector <connector>
        ^condition <condition>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a RememberConditionasB construction, combination 0.|))
}

#   Apply the operator for the RememberConditionasB construction
sp {comprehend-word*apply*match-construction*RememberConditionasB
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RememberConditionasB
        ^verb <verb>
        ^condition <condition>
        ^connector <connector>
        ^target <target>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RememberConditionasB
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of RememberAasB
              ^constituents <constituents>
              ^verb <verb>
              ^condition <condition>
              ^connector <connector>
              ^target <target>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a RememberConditionasB)
   (<constituents> ^verb <verb>
                   ^condition <condition>
                   ^connector <connector>
                   ^target <target>)
   (<e1> ^schema DoTransfer
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RememberConditionasB construction.|))
}

#   RememberConditionasB self.m.action <--> verb.m constraint
sp {comprehend-word*RememberConditionasB-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RememberConditionasB
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   RememberConditionasB self.m.object <--> condition.m constraint
sp {comprehend-word*RememberConditionasB-constraint*self-m-object*UNIFY*condition-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RememberConditionasB
          ^m <l-slot1>
          ^condition <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   RememberConditionasB self.m.object2 <--> target.m constraint
sp {comprehend-word*RememberConditionasB-constraint*self-m-object2*UNIFY*target-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RememberConditionasB
          ^m <l-slot1>
          ^target <r-slot1>)
   (<l-slot1> ^object2 { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object2 <target> -
              ^object2 <value>)
}

#   Conditional construction
sp {comprehend-word*generalize-cxn*Conditional*simple
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^name << lexical-access match-construction >>)
   (<cxn> ^subcase-of Conditional
          ^is <a>)
   (<a> -^a Conditional)
-->
   (<a> ^a Conditional)
   (<cxn> ^subcase-of Conditional -)
}

#   Propose an operator for the IfConditionThenCommand construction
sp {comprehend-word*propose*match-construction*IfConditionThenCommand
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <command>)
   (<command> ^is.a Imperative
              ^previous <conditionPart>)
   (<conditionPart> ^is.a IfConditionThen
                    ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name IfConditionThenCommand
        ^span 2
        ^command <command>
        ^conditionPart <conditionPart>
        ^previous <previous>
        ^debug-info (concat |Match a IfConditionThenCommand construction, combination 0.|))
}

#   Apply the operator for the IfConditionThenCommand construction
sp {comprehend-word*apply*match-construction*IfConditionThenCommand
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name IfConditionThenCommand
        ^conditionPart <conditionPart>
        ^command <command>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name IfConditionThenCommand
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Conditional
              ^constituents <constituents>
              ^conditionPart <conditionPart>
              ^command <command>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a IfConditionThenCommand)
   (<constituents> ^conditionPart <conditionPart>
                   ^command <command>)
   (<e1> ^schema IfThenCommand
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a IfConditionThenCommand construction.|))
}

#   IfConditionThenCommand self.m.condition <--> conditionPart.condition.declarative.m constraint
sp {comprehend-word*IfConditionThenCommand-constraint*self-m-condition*UNIFY*conditionpart-condition-declarative-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IfConditionThenCommand
          ^m <l-slot1>
          ^conditionPart <r-slot1>)
   (<l-slot1> ^condition { <target> <> <value> })
   (<r-slot1> ^condition <r-slot2>)
   (<r-slot2> ^declarative <r-slot3>)
   (<r-slot3> ^m <value>)
-->
   (<l-slot1> ^condition <target> -
              ^condition <value>)
}

#   IfConditionThenCommand self.m.command <--> command.m constraint
sp {comprehend-word*IfConditionThenCommand-constraint*self-m-command*UNIFY*command-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IfConditionThenCommand
          ^m <l-slot1>
          ^command <r-slot1>)
   (<l-slot1> ^command { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^command <target> -
              ^command <value>)
}

#   Propose an operator for the IfCondition construction
sp {comprehend-word*propose*match-construction*IfCondition
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <declarative>)
   (<declarative> ^is.a Declarative
                  ^previous <if>)
   (<if> ^is.a IF
         ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name IfCondition
        ^span 2
        ^declarative <declarative>
        ^if <if>
        ^previous <previous>
        ^debug-info (concat |Match a IfCondition construction, combination 0.|))
}

#   Apply the operator for the IfCondition construction
sp {comprehend-word*apply*match-construction*IfCondition
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name IfCondition
        ^if <if>
        ^declarative <declarative>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name IfCondition
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^if <if>
              ^declarative <declarative>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a IfCondition)
   (<constituents> ^if <if>
                   ^declarative <declarative>)
   (<e1> ^schema Condition
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a IfCondition construction.|))
}

#   IfCondition self.m.statement <--> declarative.m constraint
sp {comprehend-word*IfCondition-constraint*self-m-statement*UNIFY*declarative-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IfCondition
          ^m <l-slot1>
          ^declarative <r-slot1>)
   (<l-slot1> ^statement { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^statement <target> -
              ^statement <value>)
}

#   Propose an operator for the IfConditionThen construction
sp {comprehend-word*propose*match-construction*IfConditionThen
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <then>)
   (<then> ^is.a THEN
           ^previous <condition>)
   (<condition> ^is.a IfCondition
                ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name IfConditionThen
        ^span 2
        ^then <then>
        ^condition <condition>
        ^previous <previous>
        ^debug-info (concat |Match a IfConditionThen construction, combination 0.|))
}

#   Apply the operator for the IfConditionThen construction
sp {comprehend-word*apply*match-construction*IfConditionThen
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name IfConditionThen
        ^condition <condition>
        ^then <then>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name IfConditionThen
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Conditional
              ^constituents <constituents>
              ^condition <condition>
              ^then <then>
              ^previous <previous>)
   (<a> ^a IfConditionThen)
   (<constituents> ^condition <condition>
                   ^then <then>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a IfConditionThen construction.|))
}

#   Propose an operator for the IfConditionCommand construction
sp {comprehend-word*propose*match-construction*IfConditionCommand
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <command>)
   (<command> ^is.a Imperative
              ^previous <condition>)
   (<condition> ^is.a IfCondition
                ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name IfConditionCommand
        ^span 2
        ^command <command>
        ^condition <condition>
        ^previous <previous>
        ^debug-info (concat |Match a IfConditionCommand construction, combination 0.|))
}

#   Apply the operator for the IfConditionCommand construction
sp {comprehend-word*apply*match-construction*IfConditionCommand
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name IfConditionCommand
        ^condition <condition>
        ^command <command>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name IfConditionCommand
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Conditional
              ^constituents <constituents>
              ^condition <condition>
              ^command <command>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a IfConditionCommand)
   (<constituents> ^condition <condition>
                   ^command <command>)
   (<e1> ^schema IfThenCommand
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a IfConditionCommand construction.|))
}

#   IfConditionCommand self.m.condition <--> condition.declarative.m constraint
sp {comprehend-word*IfConditionCommand-constraint*self-m-condition*UNIFY*condition-declarative-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IfConditionCommand
          ^m <l-slot1>
          ^condition <r-slot1>)
   (<l-slot1> ^condition { <target> <> <value> })
   (<r-slot1> ^declarative <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^condition <target> -
              ^condition <value>)
}

#   IfConditionCommand self.m.command <--> command.m constraint
sp {comprehend-word*IfConditionCommand-constraint*self-m-command*UNIFY*command-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IfConditionCommand
          ^m <l-slot1>
          ^command <r-slot1>)
   (<l-slot1> ^command { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^command <target> -
              ^command <value>)
}

#   Propose an operator for the CheckCondition construction
sp {comprehend-word*propose*match-construction*CheckCondition
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <condition>)
   (<condition> ^is.a IfCondition
                ^previous <action>)
   (<action> ^is.a CHECK
             ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name CheckCondition
        ^span 2
        ^condition <condition>
        ^action <action>
        ^previous <previous>
        ^debug-info (concat |Match a CheckCondition construction, combination 0.|))
}

#   Apply the operator for the CheckCondition construction
sp {comprehend-word*apply*match-construction*CheckCondition
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name CheckCondition
        ^action <action>
        ^condition <condition>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name CheckCondition
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^action <action>
              ^condition <condition>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a CheckCondition)
   (<constituents> ^action <action>
                   ^condition <condition>)
   (<e1> ^schema CheckIt
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a CheckCondition construction.|))
}

#   CheckCondition self.m.action <--> action.m constraint
sp {comprehend-word*CheckCondition-constraint*self-m-action*UNIFY*action-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a CheckCondition
          ^m <l-slot1>
          ^action <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   CheckCondition self.m.condition <--> condition.declarative.m constraint
sp {comprehend-word*CheckCondition-constraint*self-m-condition*UNIFY*condition-declarative-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a CheckCondition
          ^m <l-slot1>
          ^condition <r-slot1>)
   (<l-slot1> ^condition { <target> <> <value> })
   (<r-slot1> ^declarative <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^condition <target> -
              ^condition <value>)
}

#   Propose an operator for the ActionForTimePeriod construction
sp {comprehend-word*propose*match-construction*ActionForTimePeriod
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <end>)
   (<end> ^is.a NumberOfUnits
          ^previous <for>)
   (<for> ^is.a FOR
          ^previous <verb>)
   (<verb> ^is.a ActionVerb
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ActionForTimePeriod
        ^span 3
        ^end <end>
        ^for <for>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a ActionForTimePeriod construction, combination 0.|))
}

#   Apply the operator for the ActionForTimePeriod construction
sp {comprehend-word*apply*match-construction*ActionForTimePeriod
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ActionForTimePeriod
        ^verb <verb>
        ^for <for>
        ^end <end>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ActionForTimePeriod
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^for <for>
              ^end <end>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a ActionForTimePeriod)
   (<constituents> ^verb <verb>
                   ^for <for>
                   ^end <end>)
   (<e1> ^schema ActionForTime
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ActionForTimePeriod construction.|))
}

#   ActionForTimePeriod self.m.action <--> verb.m constraint
sp {comprehend-word*ActionForTimePeriod-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ActionForTimePeriod
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   ActionForTimePeriod self.m.time <--> end.m constraint
sp {comprehend-word*ActionForTimePeriod-constraint*self-m-time*UNIFY*end-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ActionForTimePeriod
          ^m <l-slot1>
          ^end <r-slot1>)
   (<l-slot1> ^time { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^time <target> -
              ^time <value>)
}

#   Propose an operator for the RosieCommand construction
sp {comprehend-word*propose*match-construction*RosieCommand
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <verb>)
   (<verb> ^is.a ActionVerb
           ^previous <rosie>)
   (<rosie> ^is.a ROSIE
            ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RosieCommand
        ^span 3
        ^object <object>
        ^verb <verb>
        ^rosie <rosie>
        ^previous <previous>
        ^debug-info (concat |Match a RosieCommand construction, combination 0.|))
}

#   Apply the operator for the RosieCommand construction
sp {comprehend-word*apply*match-construction*RosieCommand
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RosieCommand
        ^rosie <rosie>
        ^verb <verb>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RosieCommand
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^rosie <rosie>
              ^verb <verb>
              ^object <object>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a RosieCommand)
   (<constituents> ^rosie <rosie>
                   ^verb <verb>
                   ^object <object>)
   (<e1> ^schema ActOnIt
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RosieCommand construction.|))
}

#   RosieCommand self.m.action <--> verb.m constraint
sp {comprehend-word*RosieCommand-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RosieCommand
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   RosieCommand self.m.object <--> object.m constraint
sp {comprehend-word*RosieCommand-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RosieCommand
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the SubjectVerb construction
sp {comprehend-word*propose*match-construction*SubjectVerb
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <verb>)
   (<verb> ^is.a ActionVerb
           ^previous <subject>)
   (<subject> ^is.a RefExpr
              ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name SubjectVerb
        ^span 2
        ^verb <verb>
        ^subject <subject>
        ^previous <previous>
        ^debug-info (concat |Match a SubjectVerb construction, combination 0.|))
}

#   Apply the operator for the SubjectVerb construction
sp {comprehend-word*apply*match-construction*SubjectVerb
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name SubjectVerb
        ^subject <subject>
        ^verb <verb>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name SubjectVerb
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^subject <subject>
              ^verb <verb>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a SubjectVerb)
   (<constituents> ^subject <subject>
                   ^verb <verb>)
   (<e1> ^schema IntransitiveAssertion
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a SubjectVerb construction.|))
}

#   SubjectVerb self.m.subject <--> subject.m constraint
sp {comprehend-word*SubjectVerb-constraint*self-m-subject*UNIFY*subject-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerb
          ^m <l-slot1>
          ^subject <r-slot1>)
   (<l-slot1> ^subject { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^subject <target> -
              ^subject <value>)
}

#   SubjectVerb self.m.verb <--> verb.m constraint
sp {comprehend-word*SubjectVerb-constraint*self-m-verb*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerb
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^verb { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^verb <target> -
              ^verb <value>)
}

#   Propose an operator for the SubjectVerbObject construction
sp {comprehend-word*propose*match-construction*SubjectVerbObject
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <subjectVerb>)
   (<subjectVerb> ^is.a SubjectVerb
                  ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name SubjectVerbObject
        ^span 2
        ^object <object>
        ^subjectVerb <subjectVerb>
        ^previous <previous>
        ^debug-info (concat |Match a SubjectVerbObject construction, combination 0.|))
}

#   Apply the operator for the SubjectVerbObject construction
sp {comprehend-word*apply*match-construction*SubjectVerbObject
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name SubjectVerbObject
        ^subjectVerb <subjectVerb>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name SubjectVerbObject
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^subjectVerb <subjectVerb>
              ^object <object>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a SubjectVerbObject)
   (<constituents> ^subjectVerb <subjectVerb>
                   ^object <object>)
   (<e1> ^schema TransitiveAssertion
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a SubjectVerbObject construction.|))
}

#   SubjectVerbObject self.m.subject <--> subjectVerb.subject.m constraint
sp {comprehend-word*SubjectVerbObject-constraint*self-m-subject*UNIFY*subjectverb-subject-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObject
          ^m <l-slot1>
          ^subjectVerb <r-slot1>)
   (<l-slot1> ^subject { <target> <> <value> })
   (<r-slot1> ^subject <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^subject <target> -
              ^subject <value>)
}

#   SubjectVerbObject self.m.verb <--> subjectVerb.verb.m constraint
sp {comprehend-word*SubjectVerbObject-constraint*self-m-verb*UNIFY*subjectverb-verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObject
          ^m <l-slot1>
          ^subjectVerb <r-slot1>)
   (<l-slot1> ^verb { <target> <> <value> })
   (<r-slot1> ^verb <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^verb <target> -
              ^verb <value>)
}

#   SubjectVerbObject self.m.object <--> object.m constraint
sp {comprehend-word*SubjectVerbObject-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObject
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the SubjectVerbObjectPP construction
sp {comprehend-word*propose*match-construction*SubjectVerbObjectPP
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <prepPhrase>)
   (<prepPhrase> ^is.a PrepPhrase
                 ^previous <clause>)
   (<clause> ^is.a SubjectVerbObject
             ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name SubjectVerbObjectPP
        ^span 2
        ^prepPhrase <prepPhrase>
        ^clause <clause>
        ^previous <previous>
        ^debug-info (concat |Match a SubjectVerbObjectPP construction, combination 0.|))
}

#   Apply the operator for the SubjectVerbObjectPP construction
sp {comprehend-word*apply*match-construction*SubjectVerbObjectPP
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name SubjectVerbObjectPP
        ^clause <clause>
        ^prepPhrase <prepPhrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name SubjectVerbObjectPP
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^clause <clause>
              ^prepPhrase <prepPhrase>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a SubjectVerbObjectPP)
   (<constituents> ^clause <clause>
                   ^prepPhrase <prepPhrase>)
   (<e1> ^schema TransitiveAssertionPrepPhrase
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a SubjectVerbObjectPP construction.|))
}

#   SubjectVerbObjectPP self.m.subject <--> clause.subjectVerb.subject.m constraint
sp {comprehend-word*SubjectVerbObjectPP-constraint*self-m-subject*UNIFY*clause-subjectverb-subject-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObjectPP
          ^m <l-slot1>
          ^clause <r-slot1>)
   (<l-slot1> ^subject { <target> <> <value> })
   (<r-slot1> ^subjectVerb <r-slot2>)
   (<r-slot2> ^subject <r-slot3>)
   (<r-slot3> ^m <value>)
-->
   (<l-slot1> ^subject <target> -
              ^subject <value>)
}

#   SubjectVerbObjectPP self.m.verb <--> clause.subjectVerb.verb.m constraint
sp {comprehend-word*SubjectVerbObjectPP-constraint*self-m-verb*UNIFY*clause-subjectverb-verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObjectPP
          ^m <l-slot1>
          ^clause <r-slot1>)
   (<l-slot1> ^verb { <target> <> <value> })
   (<r-slot1> ^subjectVerb <r-slot2>)
   (<r-slot2> ^verb <r-slot3>)
   (<r-slot3> ^m <value>)
-->
   (<l-slot1> ^verb <target> -
              ^verb <value>)
}

#   SubjectVerbObjectPP self.m.object <--> clause.object.m constraint
sp {comprehend-word*SubjectVerbObjectPP-constraint*self-m-object*UNIFY*clause-object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObjectPP
          ^m <l-slot1>
          ^clause <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^object <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   SubjectVerbObjectPP self.m.relation <--> prepPhrase.m constraint
sp {comprehend-word*SubjectVerbObjectPP-constraint*self-m-relation*UNIFY*prepphrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a SubjectVerbObjectPP
          ^m <l-slot1>
          ^prepPhrase <r-slot1>)
   (<l-slot1> ^relation { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^relation <target> -
              ^relation <value>)
}

#   Propose an operator for the ConceptIsThat construction
sp {comprehend-word*propose*match-construction*ConceptIsThat
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <isThat>)
   (<isThat> ^is.a IsThat
             ^previous <idea>)
   (<idea> ^is.a RefExpr
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ConceptIsThat
        ^span 2
        ^isThat <isThat>
        ^idea <idea>
        ^previous <previous>
        ^debug-info (concat |Match a ConceptIsThat construction, combination 0.|))
}

#   Apply the operator for the ConceptIsThat construction
sp {comprehend-word*apply*match-construction*ConceptIsThat
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ConceptIsThat
        ^idea <idea>
        ^isThat <isThat>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ConceptIsThat
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^idea <idea>
              ^isThat <isThat>
              ^previous <previous>)
   (<a> ^a ConceptIsThat)
   (<constituents> ^idea <idea>
                   ^isThat <isThat>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ConceptIsThat construction.|))
}

#   Propose an operator for the ConceptIsThatDeclarative construction
sp {comprehend-word*propose*match-construction*ConceptIsThatDeclarative
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <statement>)
   (<statement> ^is.a Declarative
                ^previous <firstPart>)
   (<firstPart> ^is.a ConceptIsThat
                ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name ConceptIsThatDeclarative
        ^span 2
        ^statement <statement>
        ^firstPart <firstPart>
        ^previous <previous>
        ^debug-info (concat |Match a ConceptIsThatDeclarative construction, combination 0.|))
}

#   Apply the operator for the ConceptIsThatDeclarative construction
sp {comprehend-word*apply*match-construction*ConceptIsThatDeclarative
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name ConceptIsThatDeclarative
        ^firstPart <firstPart>
        ^statement <statement>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name ConceptIsThatDeclarative
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^firstPart <firstPart>
              ^statement <statement>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a ConceptIsThatDeclarative)
   (<constituents> ^firstPart <firstPart>
                   ^statement <statement>)
   (<e1> ^schema ConceptIsThatAssertion
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a ConceptIsThatDeclarative construction.|))
}

#   ConceptIsThatDeclarative self.m.concept <--> firstPart.idea.m constraint
sp {comprehend-word*ConceptIsThatDeclarative-constraint*self-m-concept*UNIFY*firstpart-idea-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ConceptIsThatDeclarative
          ^m <l-slot1>
          ^firstPart <r-slot1>)
   (<l-slot1> ^concept { <target> <> <value> })
   (<r-slot1> ^idea <r-slot2>)
   (<r-slot2> ^m <value>)
-->
   (<l-slot1> ^concept <target> -
              ^concept <value>)
}

#   ConceptIsThatDeclarative self.m.assertion <--> statement.m constraint
sp {comprehend-word*ConceptIsThatDeclarative-constraint*self-m-assertion*UNIFY*statement-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a ConceptIsThatDeclarative
          ^m <l-slot1>
          ^statement <r-slot1>)
   (<l-slot1> ^assertion { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^assertion <target> -
              ^assertion <value>)
}

#   Propose an operator for the Negation construction
sp {comprehend-word*propose*match-construction*Negation
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <negator>)
   (<negator> ^is.a NOT
              ^previous <toBe>)
   (<toBe> ^is.a FiniteToBe
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name Negation
        ^span 2
        ^negator <negator>
        ^toBe <toBe>
        ^previous <previous>
        ^debug-info (concat |Match a Negation construction, combination 0.|))
}

#   Apply the operator for the Negation construction
sp {comprehend-word*apply*match-construction*Negation
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name Negation
        ^toBe <toBe>
        ^negator <negator>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name Negation
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^constituents <constituents>
              ^toBe <toBe>
              ^negator <negator>
              ^previous <previous>)
   (<a> ^a Negation)
   (<constituents> ^toBe <toBe>
                   ^negator <negator>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a Negation construction.|))
}

#   Negation self.m <--> negator.m constraint
sp {comprehend-word*Negation-constraint*self-m*UNIFY*negator-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a Negation
          ^m { <target> <> <value> }
          ^negator <r-slot1>)
   (<r-slot1> ^m <value>)
-->
   (<cxn> ^m <target> -
          ^m <value>)
}

#   Propose an operator for the RefIsNotPrepPhrase construction
sp {comprehend-word*propose*match-construction*RefIsNotPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <phrase>)
   (<phrase> ^is.a PrepPhrase
             ^previous <tobe>)
   (<tobe> ^is.a Negation
           ^previous <ref>)
   (<ref> ^is.a RefExpr
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name RefIsNotPrepPhrase
        ^span 3
        ^phrase <phrase>
        ^tobe <tobe>
        ^ref <ref>
        ^previous <previous>
        ^debug-info (concat |Match a RefIsNotPrepPhrase construction, combination 0.|))
}

#   Apply the operator for the RefIsNotPrepPhrase construction
sp {comprehend-word*apply*match-construction*RefIsNotPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name RefIsNotPrepPhrase
        ^ref <ref>
        ^tobe <tobe>
        ^phrase <phrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name RefIsNotPrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^ref <ref>
              ^tobe <tobe>
              ^phrase <phrase>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a RefIsNotPrepPhrase)
   (<constituents> ^ref <ref>
                   ^tobe <tobe>
                   ^phrase <phrase>)
   (<e1> ^schema PrepPhraseAssertion
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a RefIsNotPrepPhrase construction.|))
}

#   RefIsNotPrepPhrase self.m.preprel <--> phrase.m constraint
sp {comprehend-word*RefIsNotPrepPhrase-constraint*self-m-preprel*UNIFY*phrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefIsNotPrepPhrase
          ^m <l-slot1>
          ^phrase <r-slot1>)
   (<l-slot1> ^preprel { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^preprel <target> -
              ^preprel <value>)
}

#   RefIsNotPrepPhrase self.m.target <--> ref.m constraint
sp {comprehend-word*RefIsNotPrepPhrase-constraint*self-m-target*UNIFY*ref-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefIsNotPrepPhrase
          ^m <l-slot1>
          ^ref <r-slot1>)
   (<l-slot1> ^target { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^target <target> -
              ^target <value>)
}

#   RefIsNotPrepPhrase self.m.modifier <--> tobe.m constraint
sp {comprehend-word*RefIsNotPrepPhrase-constraint*self-m-modifier*UNIFY*tobe-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a RefIsNotPrepPhrase
          ^m <l-slot1>
          ^tobe <r-slot1>)
   (<l-slot1> ^modifier { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^modifier <target> -
              ^modifier <value>)
}

#   Propose an operator for the PropertySetIsPrepPhrase construction
sp {comprehend-word*propose*match-construction*PropertySetIsPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <phrase>)
   (<phrase> ^is.a PrepPhrase
             ^previous <tobe>)
   (<tobe> ^is.a FiniteToBe
           ^previous <ref>)
   (<ref> ^is.a PropertySet
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name PropertySetIsPrepPhrase
        ^span 3
        ^phrase <phrase>
        ^tobe <tobe>
        ^ref <ref>
        ^previous <previous>
        ^debug-info (concat |Match a PropertySetIsPrepPhrase construction, combination 0.|))
}

#   Apply the operator for the PropertySetIsPrepPhrase construction
sp {comprehend-word*apply*match-construction*PropertySetIsPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name PropertySetIsPrepPhrase
        ^ref <ref>
        ^tobe <tobe>
        ^phrase <phrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name PropertySetIsPrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^ref <ref>
              ^tobe <tobe>
              ^phrase <phrase>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a PropertySetIsPrepPhrase)
   (<constituents> ^ref <ref>
                   ^tobe <tobe>
                   ^phrase <phrase>)
   (<e1> ^schema PrepPhraseAssertion
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a PropertySetIsPrepPhrase construction.|))
}

#   PropertySetIsPrepPhrase self.m.preprel <--> phrase.m constraint
sp {comprehend-word*PropertySetIsPrepPhrase-constraint*self-m-preprel*UNIFY*phrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsPrepPhrase
          ^m <l-slot1>
          ^phrase <r-slot1>)
   (<l-slot1> ^preprel { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^preprel <target> -
              ^preprel <value>)
}

#   PropertySetIsPrepPhrase self.m.target <--> ref.m constraint
sp {comprehend-word*PropertySetIsPrepPhrase-constraint*self-m-target*UNIFY*ref-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsPrepPhrase
          ^m <l-slot1>
          ^ref <r-slot1>)
   (<l-slot1> ^target { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^target <target> -
              ^target <value>)
}

#   Propose an operator for the PropertySetIsNotPrepPhrase construction
sp {comprehend-word*propose*match-construction*PropertySetIsNotPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <phrase>)
   (<phrase> ^is.a PrepPhrase
             ^previous <tobe>)
   (<tobe> ^is.a Negation
           ^previous <ref>)
   (<ref> ^is.a PropertySet
          ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name PropertySetIsNotPrepPhrase
        ^span 3
        ^phrase <phrase>
        ^tobe <tobe>
        ^ref <ref>
        ^previous <previous>
        ^debug-info (concat |Match a PropertySetIsNotPrepPhrase construction, combination 0.|))
}

#   Apply the operator for the PropertySetIsNotPrepPhrase construction
sp {comprehend-word*apply*match-construction*PropertySetIsNotPrepPhrase
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name PropertySetIsNotPrepPhrase
        ^ref <ref>
        ^tobe <tobe>
        ^phrase <phrase>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name PropertySetIsNotPrepPhrase
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Declarative
              ^constituents <constituents>
              ^ref <ref>
              ^tobe <tobe>
              ^phrase <phrase>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a PropertySetIsNotPrepPhrase)
   (<constituents> ^ref <ref>
                   ^tobe <tobe>
                   ^phrase <phrase>)
   (<e1> ^schema PrepPhraseAssertion
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a PropertySetIsNotPrepPhrase construction.|))
}

#   PropertySetIsNotPrepPhrase self.m.preprel <--> phrase.m constraint
sp {comprehend-word*PropertySetIsNotPrepPhrase-constraint*self-m-preprel*UNIFY*phrase-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsNotPrepPhrase
          ^m <l-slot1>
          ^phrase <r-slot1>)
   (<l-slot1> ^preprel { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^preprel <target> -
              ^preprel <value>)
}

#   PropertySetIsNotPrepPhrase self.m.target <--> ref.m constraint
sp {comprehend-word*PropertySetIsNotPrepPhrase-constraint*self-m-target*UNIFY*ref-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsNotPrepPhrase
          ^m <l-slot1>
          ^ref <r-slot1>)
   (<l-slot1> ^target { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^target <target> -
              ^target <value>)
}

#   PropertySetIsNotPrepPhrase self.m.modifier <--> tobe.m constraint
sp {comprehend-word*PropertySetIsNotPrepPhrase-constraint*self-m-modifier*UNIFY*tobe-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a PropertySetIsNotPrepPhrase
          ^m <l-slot1>
          ^tobe <r-slot1>)
   (<l-slot1> ^modifier { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^modifier <target> -
              ^modifier <value>)
}

#   Propose an operator for the AskQuestion construction
sp {comprehend-word*propose*match-construction*AskQuestion
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <question>)
   (<question> ^is.a Question
               ^previous <verb>)
   (<verb> ^is.a ASK
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name AskQuestion
        ^span 2
        ^question <question>
        ^verb <verb>
        ^previous <previous>
        ^debug-info (concat |Match a AskQuestion construction, combination 0.|))
}

#   Apply the operator for the AskQuestion construction
sp {comprehend-word*apply*match-construction*AskQuestion
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name AskQuestion
        ^verb <verb>
        ^question <question>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name AskQuestion
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^verb <verb>
              ^question <question>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a AskQuestion)
   (<constituents> ^verb <verb>
                   ^question <question>)
   (<e1> ^schema AskQuestionCommand
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a AskQuestion construction.|))
}

#   AskQuestion self.m.action <--> verb.m constraint
sp {comprehend-word*AskQuestion-constraint*self-m-action*UNIFY*verb-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a AskQuestion
          ^m <l-slot1>
          ^verb <r-slot1>)
   (<l-slot1> ^action { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^action <target> -
              ^action <value>)
}

#   AskQuestion self.m.object <--> question.m constraint
sp {comprehend-word*AskQuestion-constraint*self-m-object*UNIFY*question-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a AskQuestion
          ^m <l-slot1>
          ^question <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the TransitiveVerbDefinitionSentence construction
sp {comprehend-word*propose*match-construction*TransitiveVerbDefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <object>)
   (<object> ^is.a RefExpr
             ^previous <word>)
   (<word> ^is.a UNKNOWN-WORD
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name TransitiveVerbDefinitionSentence
        ^span 2
        ^object <object>
        ^word <word>
        ^previous <previous>
        ^debug-info (concat |Match a TransitiveVerbDefinitionSentence construction, combination 0.|))
}

#   Apply the operator for the TransitiveVerbDefinitionSentence construction
sp {comprehend-word*apply*match-construction*TransitiveVerbDefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name TransitiveVerbDefinitionSentence
        ^word <word>
        ^object <object>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name TransitiveVerbDefinitionSentence
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^word <word>
              ^object <object>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a TransitiveVerbDefinitionSentence)
   (<constituents> ^word <word>
                   ^object <object>)
   (<e1> ^schema TransitiveVerbDefinition
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a TransitiveVerbDefinitionSentence construction.|))
}

#   TransitiveVerbDefinitionSentence self.m.word <--> word.word.orth constraint
sp {comprehend-word*TransitiveVerbDefinitionSentence-constraint*self-m-word*UNIFY*word-word-orth
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TransitiveVerbDefinitionSentence
          ^m <l-slot1>
          ^word <r-slot1>)
   (<l-slot1> ^word { <target> <> <value> })
   (<r-slot1> ^word <r-slot2>)
   (<r-slot2> ^orth <value>)
-->
   (<l-slot1> ^word <target> -
              ^word <value>)
}

#   TransitiveVerbDefinitionSentence self.m.object <--> object.m constraint
sp {comprehend-word*TransitiveVerbDefinitionSentence-constraint*self-m-object*UNIFY*object-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a TransitiveVerbDefinitionSentence
          ^m <l-slot1>
          ^object <r-slot1>)
   (<l-slot1> ^object { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^object <target> -
              ^object <value>)
}

#   Propose an operator for the IntransitiveVerbDefinitionSentence construction
sp {comprehend-word*propose*match-construction*IntransitiveVerbDefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^lexical-access done)
   #   Look for the constituents
   (<s> ^cxn <location>)
   (<location> ^is.a PrepPhrase
               ^previous <word>)
   (<word> ^is.a UNKNOWN-WORD
           ^previous <previous>)
-->
   (<s> ^operator <o> +)
   (<o> ^name match-construction
        ^type construction
        ^cxn-name IntransitiveVerbDefinitionSentence
        ^span 2
        ^location <location>
        ^word <word>
        ^previous <previous>
        ^debug-info (concat |Match a IntransitiveVerbDefinitionSentence construction, combination 0.|))
}

#   Apply the operator for the IntransitiveVerbDefinitionSentence construction
sp {comprehend-word*apply*match-construction*IntransitiveVerbDefinitionSentence
   (state <s> ^problem-space comprehend-word
              ^operator <o>)
   (<o> ^name match-construction
        ^cxn-name IntransitiveVerbDefinitionSentence
        ^word <word>
        ^location <location>
        ^previous <previous>)
-->
   (<s> ^cxn-new <cxn-new>)
   (<cxn-new> ^cxn-name IntransitiveVerbDefinitionSentence
              ^is <a>
              ^f <form>
              ^m <meaning>
              ^subcase-of Imperative
              ^constituents <constituents>
              ^word <word>
              ^location <location>
              ^evokes <e1>
              ^previous <previous>)
   (<a> ^a IntransitiveVerbDefinitionSentence)
   (<constituents> ^word <word>
                   ^location <location>)
   (<e1> ^schema IntransitiveVerbDefinition
         ^target <meaning>)
   #   Write a message for the construction that matched.
   (write (crlf) (concat |Matched a IntransitiveVerbDefinitionSentence construction.|))
}

#   IntransitiveVerbDefinitionSentence self.m.word <--> word.word.orth constraint
sp {comprehend-word*IntransitiveVerbDefinitionSentence-constraint*self-m-word*UNIFY*word-word-orth
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IntransitiveVerbDefinitionSentence
          ^m <l-slot1>
          ^word <r-slot1>)
   (<l-slot1> ^word { <target> <> <value> })
   (<r-slot1> ^word <r-slot2>)
   (<r-slot2> ^orth <value>)
-->
   (<l-slot1> ^word <target> -
              ^word <value>)
}

#   IntransitiveVerbDefinitionSentence self.m.location <--> location.m constraint
sp {comprehend-word*IntransitiveVerbDefinitionSentence-constraint*self-m-location*UNIFY*location-m
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^cxn-new <cxn>)
   (<o> ^type construction)
   (<cxn> ^is.a IntransitiveVerbDefinitionSentence
          ^m <l-slot1>
          ^location <r-slot1>)
   (<l-slot1> ^location { <target> <> <value> })
   (<r-slot1> ^m <value>)
-->
   (<l-slot1> ^location <target> -
              ^location <value>)
}

