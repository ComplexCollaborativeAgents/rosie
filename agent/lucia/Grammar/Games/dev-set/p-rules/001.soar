##!
# @file
#
# @created plindes 20200226
# File: 001.soar
# Author: Peter Lindes
# Created: 26 February 2020
#
# Desc: This file contains all the processing rules
#       needed to add to be able to process sentence #001
#       of the Games development set.
#


#   Propose an operator to interpret a WordDefinition
#   This operator uses the newer strategy of building
#   a message directly in interpret without going on
#   to the act operator.
sp {interpret*propose*do-word-definition
   (state <s> ^top-state <ts> 
              ^problem-space interpret
              ^comprehension <c>
              ^discourse <d>
              ^message nil)
   (<c> ^cxn-stack <cxn>)
   (<cxn> ^m <m>   #   Sometimes we need to see the syntax
          ^previous nil)    #   Otherwise there was a syntax error
   (<m> ^is.a WordDefinition)
-->
   (<s> ^operator <o> +)
   (<o> ^name do-word-definition
        ^type msg-interpretation
        ^cxn <cxn>
        ^meaning <m>
        ^discourse <d>
        ^debug-info (concat |Interpret a WordDefinition.|))
}

#   Build a message for a WordDefinition like this one:
#       The name of the puzzle is blocks-world.
# TAKE THIS MEANING:
#	(M11 ^is A36 ^object M9 ^schema-name WordDefinition ^source I20
#	       ^text |The name of the puzzle is blocks-world.| ^word blocks-world)
#	  (A36 ^a WordDefinition)
#	  (M9 ^category M2 ^givenness definite ^is A30 ^modifiers nil ^name nil
#	         ^predicate L29 (@166) ^referent nil ^relation M8 ^schema-name RefDesc
#	         ^source I17 ^text |The name of the puzzle|)
#	    (M2 ^concept-handle name1 ^concept-type nil ^is A7 ^predicate L18 (@166)
#	           ^rosie-category concept ^schema-name Name ^source I10 ^text name)
#	      (A7 ^a Concept ^a Name ^a Entity)
#	      (L18 ^handle name1 ^property L19 (@155))
#	        (L19 ^handle concept ^type conceptual)
#	      (I10 ^left 1 ^right 1)
#	    (A30 ^a RefDesc)
#	    (L29 ^handle name1 ^property L30 (@155))
#	      (L30 ^handle concept ^type conceptual)
#	    (M8 ^is A26 ^object M7 ^prep of1 ^schema-name PrepRelation ^source I16
#	           ^text |of the puzzle|)
#	      (A26 ^a PrepRelation)
#	      (M7 ^category M6 ^givenness definite ^is A24 ^modifiers nil ^name Puzzle
#	             ^predicate L27 (@160) ^referent nil ^relation nil
#	             ^schema-name RefDesc ^source I15 ^text |the puzzle|)
#	        (M6 ^concept-handle puzzle1 ^concept-type nil ^is A20
#	               ^predicate L25 (@160) ^rosie-category concept
#	               ^schema-name Puzzle ^source I14 ^text puzzle)
#	        (A24 ^a RefDesc)
#	        (L27 ^handle puzzle1 ^property L28 (@155))
#	        (I15 ^left 3 ^right 4)
#	      (I16 ^left 2 ^right 4)
#	    (I17 ^left 0 ^right 4)
#	  (I20 ^left 0 ^right 6)
# AND BUILD A MESSAGE LIKE THIS:
#	(I25 ^arg1 I43 ^message-type object-description ^predicate N38)
#	  (I43 ^2 I44 ^handle of1 ^item-type predicate)
#	    (I44 ^2 N15 ^handle name1)
#	      (N15 ^handle puzzle1 ^property L47 (@100165))
#	        (L47 ^handle concept ^type conceptual)
#	  (N38 ^handle blocks-world1 ^item-type predicate
#	         ^word-structure N37 (@999000))
#	    (N37 ^referent R114 (@999001) ^spelling blocks-world)
#	      (R114 ^handle blocks-world1 ^word-structure N37 (@999000))
sp {interpret*apply*do-word-definition
   (state <s> ^top-state <ts> 
              ^problem-space interpret
              ^operator <o>
              ^message nil)
   (<o> ^name do-word-definition
        ^meaning <m>)
   (<m> ^is.a WordDefinition
        ^object <ref-desc>
        ^word <word>)
   #    Get a RefDesc
   (<ref-desc> ^is.a RefDesc
               ^predicate <predicate>
               ^relation <relation>)
   #    Find the main noun
   (<predicate> ^handle <noun-1>
                ^property <pred-prop>)
   (<pred-prop> ^handle concept
                ^type conceptual)
   #    Find the preposition
   (<relation> ^is.a PrepRelation
               ^prep <prep>
               ^object <pp-object>)
   #    Find the secondary noun
#   (<pp-object> ^is.a << RefDesc PropertySetDescriptor >>
   (<pp-object> ^is.a RefDesc
                ^predicate <predicate-2>)
   (<predicate-2> ^handle <noun-2>
                  ^property <pred-2-prop>)
   (<pred-2-prop> ^handle concept
                  ^type conceptual)
   (<ts> ^io.output-link <output>)
-->
   #    Build the message
   (<s> ^message nil -
        ^message <message>)
   (<message> ^predicate <msg-predicate>
              ^message-type object-description
              ^arg1 <arg1>)
   #    Build the arg1
   (<arg1> ^item-type predicate
           ^handle <prep>
           ^2 <n-2-1>)
   (<n-2-1> ^handle <noun-1>
            ^2 <n-2-2>)
   (<n-2-2> ^property <n-2-2-prop>
            ^handle <noun-2>)
   (<n-2-2-prop> ^type conceptual
                 ^handle concept)
   #    Build the predicate
   (<msg-predicate> ^word-structure <word-struct>
                    ^item-type predicate
                    ^handle (concat <word> |1|))
   (<word-struct> ^spelling <word>
                  ^referent <referent>)
   (<referent> ^word-structure <word-struct>
               ^handle (concat <word> |1|))
   #    Mark things to store in smem
   (<s> ^store-concept <word-struct>
        ^store-concept <referent>)
}


