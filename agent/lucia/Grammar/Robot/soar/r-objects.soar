#   Soar code produced automatically 
#   from file 'C:\Users\plind\OneDrive\GitHub\PLCode\Lucia\Grammars\Robot\ecg\r-objects.ecg'.

#   ObjectNotBlock schema
sp {comprehend-word*evoked-schema*ObjectNotBlock*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema ObjectNotBlock
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name ObjectNotBlock
               ^is <a>
               ^shape nil
               ^color nil
               ^size nil
               ^category nil
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a ObjectNotBlock)
   (<e1> ^schema RosieObject
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value object)
   (<c2> ^attr movable
         ^value true)
}

#   ObjectNotBlock schema
sp {comprehend-word*evoked-schema*ObjectNotBlock*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema ObjectNotBlock
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^shape nil
               ^color nil
               ^size nil
               ^category nil
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a ObjectNotBlock)
   (<e1> ^schema RosieObject
         ^target <e-target>)
   (<c1> ^attr rosie-category
         ^value object)
   (<c2> ^attr movable
         ^value true)
}

#   Fork schema
sp {comprehend-word*evoked-schema*Fork*create
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Fork
             ^target <e-target>)
   (<e-target> -^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<e-target> ^schema-name Fork
               ^is <a>
               ^constraint <c1>
               ^constraint <c2>)
   (<a> ^a Fork)
   (<e1> ^schema ObjectNotBlock
         ^target <e-target>)
   (<c1> ^attr movable
         ^value true)
   (<c2> ^attr category
         ^value fork1)
}

#   Fork schema
sp {comprehend-word*evoked-schema*Fork*exists
   (state <s> ^problem-space comprehend-word
              ^operator <o>
              ^<< cxn cxn-new >> <cxn>)
   (<o> ^type construction)
   (<cxn> ^evokes <evoked>)
   (<evoked> ^schema Fork
             ^target <e-target>)
   (<e-target> ^is <a>)
-->
   (<cxn> ^evokes <evoked> -
          ^evokes <e1>)
   (<a> ^a Fork)
   (<e1> ^schema ObjectNotBlock
         ^target <e-target>)
   (<e-target> ^constraint <c1>
               ^constraint <c2>)
   (<c1> ^attr movable
         ^value true)
   (<c2> ^attr category
         ^value fork1)
}

