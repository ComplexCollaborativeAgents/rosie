
#temp quick version for games, predicates
sp {interpret-message*propose*interpret-unknown-word
   (state <s> ^name interpret-message 
              ^instructor-message <msg>)
   (<msg> ^type unknown-word ^word <word>)
-->
    (interrupt)
#(write (crlf) (cmd print <msg>))
   (<s> ^operator <o> + > =)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^message <msg>)
}

sp {interpret-message*prefer*interpret-unknown-word*alphabetic*ordering
   (state <s> ^name interpret-message
              ^operator <o2> +
                ^operator <o> +)
   (<o> ^name interpret-unknown-word
        ^word <word> -^word adjacent)
   (<o2> ^name interpret-unknown-word
         ^word {<w> > <word>})
-->
    (<s> ^operator <o> > <o2>)
}

#prefer adjacent last #need to be able to detect it has two arguments.
sp {interpret-message*prefer*interpret-unknown-word*adjacent
   (state <s> ^name interpret-message
              ^operator <o2> +
                ^operator <o> +)
   (<o> ^name interpret-unknown-word
        -^word adjacent)
   (<o2> ^name interpret-unknown-word
        ^word adjacent)
-->
    (<s> ^operator <o> > <o2>)
}


# Mark the message as interpreted (retracts operator)
#   And send message to human
sp {interpret-message*apply*interpret-unknown-word*remove-new-unknown
   (state <s> ^name interpret-message
              #^unprocessed-next nil
              ^top-state.dialog-context <dc>
              ^operator <o>)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^message <msg>)
   (<dc> ^new-unknown <word>)
-->
    (<dc> ^new-unknown <word> -)
 }

sp {interpret-message*apply*interpret-unknown-word*create*segment
   (state <s> ^name interpret-message
              #^unprocessed-next nil
              ^top-state.dialog-context <dc>
              ^top-state.interaction.changes <c>
              ^operator <o>)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^message <msg>)
 # -{(<dc> ^learning-predicate <lp2>)
 #   (<lp2> -^name <word>)}
-->
    (<c> ^new-segment-info <info>)
   (<info> ^purpose <p>
           ^originator agent)
   (<p> ^type process-unknown-word
        ^parameters.word <word>
        ^satisfaction <sat>)
   (<sat> ^dialog-event <de>)
   (<de> ^type process-unknown-word
          ^originator instructor)
   (<dc> ^learning-predicate <lp>)
   (<lp> ^name <word>)
   (<s> ^mark-interpreted <msg>)
   (<s> ^outgoing-message <out-msg>)
   (<out-msg> ^type unknown-word
              ^fields.word <word>)
}
#TODO FIX HACK NEED lexical info from failed parse to know multy arguments/preceeding word
#adjectives: low high top bottom dark dim warm cool cold hot heavy light covered clear free weak strong captured occupied matched -ed highest brightest -est
#is a/the/an X object
sp {interpret-message*apply*interpret-unknown-word*store-smem-word*X-OBJ-ADJ
   (state <s> ^name interpret-message
              ^smem.command <sc>
              ^operator <o>)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^word << box frog toad grape grapefruit >>
        ^message <msg>)
   (<msg> ^before << a the an >>)# -^after |.|)
-->
    (<sc> ^store <w1> <spell> <p3>)
    (<w1> ^handle <word> ^property <p3>)
    (<spell> ^spelling <word> ^structure-type ADJ ^referent <w1>)
    (<p3> ^handle property ^type visual ^item-type property)  
}
#sp {interpret-message*apply*interpret-unknown-word*store-smem-word*X-ADJ
#   (state <s> ^name interpret-message
#              ^smem.command <sc>
#              ^operator <o>)
#   (<o> ^name interpret-unknown-word
#        ^word <word>
#        -^word << box frog toad grape grapefruit >>
#        ^message <msg>) 
#(<msg> ^before is -^after << to than of >>)
#-->
#    (<sc> ^store <w1> <spell> <p3>)
#    (<w1> ^handle <word> ^property <p3>)
#    (<spell> ^spelling <word> ^structure-type ADJ ^referent <w1>)
#    (<p3> ^handle property ^type visual ^item-type property)  
#}

# ^word << box frog toad grape grapefruit >>
sp {interpret-message*apply*interpret-unknown-word*store-smem-word*noun
    :interrupt
   (state <s> ^name interpret-message
              ^smem.command <sc>
              ^operator <o>)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^word << box frog toad grape grapefruit >>
        ^message <msg>)
  # (<msg> ^before << a the an >> ^after |.|)
-->
    (<sc> ^store <w1> <spell> <pp>)
    (<w1> ^handle <word> ^item-type predicate ^property <pp>)
    (<pp> ^handle property ^type visual ^item-type property)
    (<spell> ^spelling <word> ^structure-type N ^number singular ^referent <w1>)  
}

#smaller larger lower higher weaker stronger heavier lighter darker dimmer warmer brighter colder 
sp {interpret-message*apply*interpret-unknown-word*store-smem-word*x-than
    :interrupt
   (state <s> ^name interpret-message
              ^smem.command <sc>
              ^operator <o>)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^message <msg>)
   (<msg> ^before is ^after than)
-->
    (<sc> ^store <w1> <spell> <next> <next-to1> )
    (<w1> ^handle <word>)
    (<spell> ^spelling <word> ^structure-type C-ADJ ^converts-to C-ADJ-P ^relation <w1>)  
    (<next> ^prior-word <word>
                   ^current-word |than|
                   ^spelling (concat <word> |-than|)
                   ^structure-type C-ADJ
                   ^relation <w1>
                   ^assigners <next-to1>
                   ^converts-to C-ADJ-P)
           (<next-to1> ^structure-type DP
                    ^relative-position after
                    ^syntactic-structure head
                    ^required true)
}
 
#^word << passenger owner partner score husband wife position neighbor occupant row-constraints column-constraints section-constraints total-constraints >>
#TODO hack lost information that following word is of... need to recover
sp {interpret-message*apply*interpret-unknown-word*store-smem-word*x-of
   (state <s> ^name interpret-message
              ^smem.command <sc>
              ^operator <o>)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^message <msg>)
   (<msg> ^after of)
-->
    (<sc> ^store <w1> <spell> <p3>)
    (<w1> ^handle <word> ^property <p3>)
    (<spell> ^spelling <word> ^structure-type N ^syntactic-referent-type ADJ ^number singular ^referent <w1>)
    (<p3> ^handle property ^type conceptual ^item-type property)
}        

#other -to
#next to, adjacent
#TODO hack lost information that following word is to and has 2 args... need to recover
sp {interpret-message*apply*interpret-unknown-word*store-smem-word*x-to
   (state <s> ^name interpret-message
              ^smem.command <sc>
              ^top-state.dialog-context <dc>
              ^operator <o>)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^message <msg>)
   (<msg> ^before is ^after to)
-->
    (<sc> ^store <w1> <spell> <next> <next-to1> )
    (<w1> ^handle <word>)
    (<spell> ^spelling <word> ^structure-type P ^converts-to PP ^relation <w1>)
              (<next> ^prior-word <word>
                   ^current-word |to|
                   ^spelling (concat <word> |-to|)
                   ^structure-type P
                   ^relation <w1>
                   ^assigners <next-to1>
                   ^converts-to PP)
           (<next-to1> ^structure-type DP
                    ^relative-position after
                    ^syntactic-structure head
                    ^required true)
    
}

#^word << on in below above near under behind around besides >>
sp {interpret-message*apply*interpret-unknown-word*store-smem-word*prep
:interrupt
   (state <s> ^name interpret-message
              ^smem.command <sc>
              ^top-state.dialog-context <dc>
              ^operator <o>)
   (<o> ^name interpret-unknown-word
        ^word <word>
        ^message <msg>)
   (<msg> ^before is -^after << than to of >> -^after |.|)
-->
    (<sc> ^store <w1> <spell> <st> <plt>)
    (<w1> ^handle <word> ^item-type relation ^relation-type existing ^relation <x>)
    (<spell> ^spelling <word> ^super-type <st> ^relation <w1>)
    (<st> ^structure-type P
                   ^relation-type binary
                   ^assigners <plt>
                   ^converts-to PP)
           (<plt> ^structure-type DP
                    ^relative-position after
                    ^syntactic-structure head
                    ^required true)
} 

    

