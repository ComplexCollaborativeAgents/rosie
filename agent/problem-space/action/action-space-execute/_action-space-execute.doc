############## problem-space.action-space execute ###############

### State Representation ###
action-operator: The operator representing this task
action-id: The root LTI for the smem knowledge about this task

action-stack: The top-state stack representing the current task decomposition
current-action: The segment on the action-stack for this substate
parent-action: The parent task's action segment
child-action: The child task's action segment




### Problem Space ###
(<ps> ^name action
      ^action-space execute
	  ^world.copy-type shallow)

### Operators ###
remove-start-of-execution-flag
  When an action-stack segment is first created, it has ^start-of-execution true
  First time an execute-action substate is reached, this flag is removed

smem-query [retrieve-action-id]
  Will retrieve the smem info for the action being executed

init-current-subgoal
  Will initialize ^action-operator.current-subgoal if not present

<child-action>
  If there is a child-action segment with an execution-operator, propose it

pop-action-segment
  If the child-action segment is satisfied, pop it

advance-current-subgoal
  If the current-subgoal is satisfied and there is another subgoal, 
    change the current-subgoal on the action-operator
  

wait
  If the flag ^propose-wait true is on the state, this will propose a wait operator


  apply-learned-subaction-proposal.soar
  complete-action.soar
  copy-action.soar
  learn-task-subaction.soar
  pop-action-segment.soar
  preferences.soar
  push-action-segment.soar


### Knowledge Needed ###
Goal Elaboration
Subaction Proposals
Selection Knowledge


###############################################################
# Previous

These rules are specific to when the agent is trying to execute
actions in the real world

### elaborations
   current-action : action segment, copied from superstate
   parent-action  : the previous action segment
   child-action   : the next action segment
   action-matched <bool> : if the match-action has a match

### validate-child-action
    If a child-action is there, and it has not been validated, 
    This will try to match it against proposed action operators
    If it does match, it will mark the child-action as validated

### apply-primitive-action
    When a primitive action is selected through preferences in a composite task,
    Create a new segment to push onto the action stack for that primitive action

### report-success
    This operator will mark the current-action with ^status success, 
    and clean up any output commands that were made
    For composites: proposed if desired.satisfied true
    For primatives: proposed if the action is finished, 
      (See proposals in execute-action/execute-primitive-action)

### report-failure
   This operator will mark the current-action with ^status failure,
   Remove any commands on the output-link,
   And will copy any failure info onto the current action (failure-type and failure-info)
   For primatives: proposed individually if the action fails
      (See proposals in execute-action/execute-primitive-action)

### pop-finished-action
   If there is a status on the current-action, this will pop it from the stack


### learn-task-subaction
    If the child-action doesn't match a proposed action, 
    and it is labeled with ^learn-proposal true, 
    then create a new smem rep of that subaction to store (<s> ^store-subaction <sub>)

### store-subaction
    When there is a ^store-subaction <sub> wme on the state, 
    This will store it in smem and add it to the action-id.procedural info
