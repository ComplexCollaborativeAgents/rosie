These are rules for the action problem-space
They are organized by the problem-space structure


problem-space
	^name action
   ^propose-task-operators << true false >>
      If true, proposes operators for the primitive actions [see propose-task-operators.soar]
   ^propose-driving-operators << true false >>
      If true, proposes operators for the driving actions [see propose-driving-operators.soar]
      These have no preconditions/action models 
			
			
######################## State Elaborations ##########################
			[see files in state-elaborations folder]

These rules are general elaboration rules that can apply to any state that has the proper structures

## task-concept-network
 The smem lti and substructure with information about the current action
 By default, elaborated from the superstate
 
## task-operator
 The superoperator for the action being executed
 By default, its from superstate.operator
   But it can be deep copied if there is a ^deep-copy-task-operator <op> on the state
   (for example, during evaluate-operator)
 
## instantiate-task-argument
 These rules take a general representation of an action argument (smem rep)
   and generate an instance grounded in the world

 They fire if a instantiate-task-argument structure is on the state
   (state <s> ^instantiate-task-argument <arg>)
   (<arg> ^arg-type << object concept predicate until-clause >>
          ^arg-status abstract # Optional: generate new rep instead of connecting to world
          ^general-arg-rep <rep>) # usually the smem representation of the argument
   Also expects the following on the state: 
     task-operator, task-concept-network, world
   Will create an ^instantiation <ins> rep of the argument under <arg>
   
   
## match-task-operator
 These rules will attempt to match an task-operator 
   against the currently proposed set of tasks and find a match

 They fire if an match-task-operator structure is on the state
   (state <s> ^match-task-operator <mto>)
   (<mto> ^task-operator <task>)  # task-operator representation
 Will elaborate ^successful-match <op> under match-task-operator for each 
   proposed operator (or evaluate-operator) which matches the task-operator
   
     
## until-clause
 These rules will check if an until-clause on the state is satisfed
   By default, elaborated from task-operator.until-clause

 They fire if an until-clause structure is on the state
   (state <s> ^until-clause <until>)
   (<until> ^prediate <pred>)  # Can be more than 1 predicate
   (<pred> ^type << state relation >>
           ^handle <pred-handle>
           ^1 <obj1>
           ^2 <obj2>) # may have 2 or more arguments if a relation
  Also expects the following on the state: 
     world
  Will elaborate each predicate with ^satisfied true, 
     and elaborates the until-clause with ^satisfied true if all predicates are satisfied


## desired
 These rules will check if a desired structure (goal) is satisfied

 They fire is a desired structure is on the state in an action problem-space
   (state <s> ^desired <des>)
   (<des> ^predicate <pred>)   # Can be more than 1 predicate
   (<pred> ^type << state relation >>
           ^handle <pred-handle>
           ^1 <obj1>
           ^2 <obj2>) # may have 2 or more arguments if a relation
 Also expects the following on the state: 
     world
 Will elaborate each predicate with ^satisfied true, 
     and elaborates the desired structure with ^satisfied true if all predicates are satisfied
