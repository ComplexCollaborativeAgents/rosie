
# Remove any performed subtask flags
sp {subproblem*execute*apply*select-next-goal*remove*performed-subtask
   (state <s> ^problem-space.subproblem execute
              ^operator.name select-next-goal
              ^task-operator <task-op>)
   (<task-op> ^performed <sub-h>)
-->
   (<task-op> ^performed <sub-h> -)
}

###################### select-next-goal ##################
# When the current goal is satisfied, select the next one in the graph

# This will learn an application rule which will change the goal is one step

# Elaborate problem-space, turn learning on
sp {subproblem*execute*select-next-goal*force-learn
   (state <s> ^name select-next-goal)
-->
   (<s> ^default-problem-space no)
   (force-learn <s>)
}

# Elaborate superstate info
sp {subproblem*execute*select-next-goal*elaborate*next-goal-handle
   (state <s> ^name select-next-goal
              ^superstate.operator.next-goal-handle <goal-h>)
-->
   (<s> ^next-goal-handle <goal-h>)
}

# Elaborate task-operator
sp {subproblem*execute*select-next-goal*elaborate*task-operator
   (state <s> ^name select-next-goal
              ^superstate.task-operator <task-op>)
-->
   (<s> ^task-operator <task-op>)
}

# Elaborate task-handle from task-operator
sp {subproblem*execute*select-next-goal*elaborate*task-handle
   (state <s> ^name select-next-goal
              ^task-operator.task-handle <task-h>)
-->
   (<s> ^task-handle <task-h>)
}

# Retrieve the goal node from smem
sp {subproblem*execute*select-next-goal*retrieve*next-goal-id
   (state <s> ^name select-next-goal
              ^next-goal-handle <goal-h>)
-->
  (<s> ^smem-query <query>)
  (<query> ^cue.handle <goal-h>
           ^depth 5
           ^destination <s>
           ^result-name next-goal-id)
}

# Retrieve the task-concept-network from smem
sp {subproblem*execute*select-next-goal*retrieve*TCN
   (state <s> ^name select-next-goal
              ^task-handle <task-h>)
-->
   (<s> ^smem-query <query>)
   (<query> ^cue <cue>
            ^depth 8
            ^destination <s>
            ^result-name task-concept-network)
   (<cue> ^handle <task-h>)
}

# If there are any objects in the goal that are not part of the task-operator, 
#   they are implicit object arguments and should be added to the world
sp {subproblem*execute*select-next-goal*elaborate*object-slot
   (state <s> ^name select-next-goal
              ^next-goal-id.{ << 1 2 3 4 5 >> } <gp>
              ^task-concept-network.procedural <proc>)
   (<gp> ^type << unary relation >>
         ^{ << 1 2 >> } <obj-slot>)
#   (<proc> -^<arg-name>.<slot-name> { @ <obj-slot> })
-->
   (<s> ^object-slot <obj-slot>)
}

sp {subproblem*execute*select-next-goal*elaborate*explicit-object-slot
   (state <s> ^name select-next-goal
              ^object-slot <obj-slot>
              ^task-concept-network.procedural <proc>)
   (<proc> ^<arg-name>.<slot-name> { @ <obj-slot> })
-->
   (<s> ^explicit-object-slot <obj-slot>)
}

sp {subproblem*execute*select-next-goal*elaborate*implicit-object*1*pred
   (state <s> ^name select-next-goal
              ^object-slot <obj-slot>
             -^explicit-object-slot <obj-slot>)
   (<obj-slot> ^default <def>)
   (<def> ^<prop1> <pred1>
         -^{ <prop2> <> <prop1> })
-->
   (<s> ^implicit-object <obj>)
   (<obj> ^default <def-copy>)
   (<def-copy> ^<prop1> <pred1>)
}

### Operator learn-apply-rule
sp {subproblem*execute*select-next-goal*propose*learn-apply-rule
   (state <s> ^name select-next-goal
              ^task-handle <task-h>
              ^task-concept-network.handle <task-h>
              ^next-goal-handle <goal-h>
              ^next-goal-id.handle <goal-h>)
-->
   (<s> ^operator <o> +)
   (<o> ^name learn-apply-rule)
}

# ENUMERATE: implicit objects on a goal (0-3)

sp {subproblem*execute*apply*select-next-goal*change*current-goal*0*implicit
   (state <s> ^name select-next-goal
              ^operator.name learn-apply-rule
              ^next-goal-handle <goal-h>
              ^task-operator <task-op>
             -^implicit-object)
   (<task-op> ^current-goal { <cur-goal-h> <> <goal-h> })
-->
   (<task-op> ^current-goal <cur-goal-h> -
              ^current-goal <goal-h>)
}

sp {subproblem*execute*apply*select-next-goal*change*current-goal*1*implicit
   (state <s> ^name select-next-goal
              ^operator.name learn-apply-rule
              ^superstate <ss>
              ^next-goal-handle <goal-h>
              ^task-operator <task-op>
              ^implicit-object   <obj1>
             -^implicit-object { <obj2> <> <obj1> })
   (<task-op> ^current-goal { <cur-goal-h> <> <goal-h> })
-->
   (<task-op> ^current-goal <cur-goal-h> -
              ^current-goal <goal-h>)
   (<ss> ^implicit-object <obj1>)
}

sp {subproblem*execute*apply*select-next-goal*change*current-goal*2*implicit
   (state <s> ^name select-next-goal
              ^operator.name learn-apply-rule
              ^superstate <ss>
              ^next-goal-handle <goal-h>
              ^task-operator <task-op>
              ^implicit-object <obj1>
              ^implicit-object { <obj2> > <obj1> }
             -^implicit-object { <obj3> <> <obj2> <> <obj1> })
   (<task-op> ^current-goal { <cur-goal-h> <> <goal-h> })
-->
   (<task-op> ^current-goal <cur-goal-h> -
              ^current-goal <goal-h>)
   (<ss> ^implicit-object <obj1> <obj2>)
}

sp {subproblem*execute*apply*select-next-goal*change*current-goal*3*implicit
   (state <s> ^name select-next-goal
              ^operator.name learn-apply-rule
              ^superstate <ss>
              ^next-goal-handle <goal-h>
              ^task-operator <task-op>
              ^implicit-object <obj1>
              ^implicit-object { <obj2> > <obj1> }
              ^implicit-object { <obj3> > <obj2> }
             -^implicit-object { <obj4> <> <obj3> <> <obj2> <> <obj1> })
   (<task-op> ^current-goal { <cur-goal-h> <> <goal-h> })
-->
   (<task-op> ^current-goal <cur-goal-h> -
              ^current-goal <goal-h>)
   (<ss> ^implicit-object <obj1> <obj2> <obj3>)
}
