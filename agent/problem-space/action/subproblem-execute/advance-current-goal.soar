# This operator will advance the current-goal on the task-operator
#   when the current goal in the goal-graph has been completed

### PROPOSALS

# For a new task, advance to the first goal
sp {subproblem*execute*propose*advance-current-goal*first
   (state <s> ^problem-space.subproblem execute
              ^task-operator <task-op>)
   (<task-op> ^current-goal first)
-->
   (<s> ^operator <o> + > =)
   (<o> ^name advance-current-goal
        ^current-goal first)
}

# When the current goal is satisfied, advance to the next
sp {subproblem*execute*propose*advance-current-goal
   (state <s> ^problem-space.subproblem execute
              ^task-operator <task-op>
              ^desired <des>)
   (<des> ^handle <goal-handle>
          ^satisfied true)
   (<task-op> ^current-goal <goal-handle>)
-->
   (<s> ^operator <o> + > =)
   (<o> ^name advance-current-goal
        ^current-goal <goal-handle>)
}

# If the goal condition is unmet, advance to the next
sp {subproblem*execute*propose*advance-current-goal*unsatisfied-conditions
   (state <s> ^problem-space.subproblem execute
              ^task-operator <task-op>
              ^desired <des>)
   (<des> ^handle <goal-handle>
          ^unsatisfied-conditions true)
   (<task-op> ^current-goal <goal-handle>)
-->
   (<s> ^operator <o> + > =)
   (<o> ^name advance-current-goal
        ^current-goal <goal-handle>)
}

### ELABORATE next-goal

# If current-goal=first, Choose the first goal from the goal-graph
sp {subproblem*execute*elaborate*advance-current-goal*first
   (state <s> ^problem-space.subproblem execute
              ^operator <o> +
              ^task-concept-network.goal-graph.first.handle <goal-handle>)
   (<o> ^name advance-current-goal
        ^current-goal first)
-->
   (<o> ^next-goal <goal-handle>)
}

# Otherwise, follow the current goal's next pointer
sp {subproblem*execute*elaborate*advance-current-goal*next
   (state <s> ^problem-space.subproblem execute
              ^operator <o> +
              ^task-concept-network.goal-graph.goal <g>)
   (<o> ^name advance-current-goal
        ^current-goal <goal-handle>)
   (<g> ^handle <goal-handle>
        ^next.handle <next-handle>)
-->
   (<o> ^next-goal <next-handle>)
}

# If the current goal has next=complete, we make current-goal=complete
sp {subproblem*execute*elaborate*advance-current-goal*complete
   (state <s> ^problem-space.subproblem execute
              ^operator <o> +
              ^task-concept-network.goal-graph.goal <g>)
   (<o> ^name advance-current-goal
        ^current-goal <goal-handle>)
   (<g> ^handle <goal-handle>
        ^next complete)
-->
   (<o> ^next-goal complete)
}

### REJECT

# If there is no next goal, reject advance-current-goal
sp {subproblem*execute*reject*advance-current-goal*no*next-goal
   (state <s> ^problem-space.subproblem execute
              ^operator <o> +
             -^current-task-segment.finish-task true)
   (<o> ^name advance-current-goal
       -^next-goal)
-->
   (<s> ^operator <o> -)
}

### APPLICATION

# Change the current-goal on the task-operator
sp {subproblem*execute*apply*advance-current-goal*change*current-goal
   (state <s> ^problem-space.subproblem execute
              ^operator <o>
              ^task-operator <task-op>)
   (<o> ^name advance-current-goal
        ^current-goal <cur-handle>
        ^next-goal <next-handle>)
   (<task-op> ^current-goal <cur-handle>)
-->
   (<task-op> ^current-goal <cur-handle> -
              ^current-goal <next-handle>)
}

# If any subtasks were marked as performed, remove those flags from the task-operator
sp {subproblem*execute*apply*advance-current-goal*remove*performed-subtask
   (state <s> ^problem-space.subproblem execute
              ^operator <o>
              ^task-operator <task-op>)
   (<o> ^name advance-current-goal
        ^next-goal <next-handle>)
   (<task-op> ^performed <sub-h>)
-->
   (<task-op> ^performed <sub-h> -)
}

# If there is no next goal but we were told "You are done" (task-finished true)
#    we update the goal in the goal-graph to have ^next complete to mark the task endpoint
sp {subproblem*execute*apply*advance-current-goal*mark*current-goal*next*complete
   (state <s> ^problem-space.subproblem execute
              ^operator <o>
              ^task-concept-network.goal-graph.goal <cur-goal>
              ^current-task-segment.finish-task true
             -^current-task-segment.repeat-to-goal
              ^smem.command <cmd>)
   (<o> ^name advance-current-goal
        ^current-goal <goal-handle>)
   (<cur-goal> ^handle <goal-handle>
               ^next none)
-->
   (<cur-goal> ^next none -
               ^next complete)
   (<cmd> ^store <cur-goal>)
}

# If we are told you are done and there is a repeat-to-goal structure, go to that goal
sp {subproblem*execute*apply*advance-current-goal*mark*current-goal*next*complete*repeat-to-goal
   (state <s> ^problem-space.subproblem execute
              ^operator <o>
              ^task-concept-network.goal-graph.goal <cur-goal>
              ^task-concept-network.goal-graph.goal <next-goal>
              ^current-task-segment.finish-task true
              ^current-task-segment.repeat-to-goal <next-goal-handle>
              ^smem.command <cmd>)
   (<o> ^name advance-current-goal
        ^current-goal <goal-handle>)
   (<cur-goal> ^handle <goal-handle>
               ^next none)
   (<next-goal> ^handle <next-goal-handle>
                ^next <repeat-next>)
-->
   (<cur-goal> ^next none -
               ^next <repeat-next>)
   (<cmd> ^store <cur-goal>)
}

sp {subproblem*execute*apply*advance-current-goal*mark*implicit-object
   (state <s> ^problem-space.subproblem execute
              ^operator <o>
              ^task-concept-network <tcn>)
   (<o> ^name advance-current-goal
        ^next-goal <goal-handle>)
   (<tcn> ^goal-graph.goal <next-goal>
          ^procedural <proc>)
   (<next-goal> ^handle <next-goal-handle>
                ^{ << predicates conditions >> }.{ << 1 2 3 4 5 >> } <pred>)
   (<pred> ^type << unary relation >>
           ^{ << 1 2 >> } <obj-slot>)
   (<proc> -^<arg-name>.<slot-name> <obj-slot>)
-->
   (<s> ^implicit-object <obj-slot>)
}
## 
#sp {subproblem*execute*propose*advance-current-goal*unsatisfied*conditional*action
#   (state <s> ^problem-space.subproblem execute
#              ^evaluate-subtask-conditions.instantiation <i>
#              ^task-concept-network.goal <g>
#              ^task-operator <task-op>)
#   (<g> ^goal-count <c>
#        ^{ <g-num> < <c> }.handle <goal-handle>)
#   (<task-op> ^current-goal <goal-handle>)
#   (<i> -^satisfied true)
#-->
#   (<s> ^operator <o> + > =)
#   (<o> ^name advance-current-goal
#        ^next-goal-num (+ <g-num> 1))
#}

sp {subproblem*execute*propose*add-object-to-world*implicit-object
   (state <s> ^problem-space.subproblem execute
              ^implicit-object <obj>)
-->
   (<s> ^operator <o> + =)
   (<o> ^name add-object-to-world
        ^source-type tcn-obj-slot
        ^source-obj <obj>)
}

sp {subproblem*execute*propose*add-object-to-world*implicit-object*cleaup
   (state <s> ^problem-space.subproblem execute
              ^operator.name add-object-to-world
              ^implicit-object <obj>
              ^add-object-result <res>)
   (<res> ^source-obj <obj>)
-->
   (<s> ^implicit-object <obj> -
        ^add-object-result <res> -)
}
